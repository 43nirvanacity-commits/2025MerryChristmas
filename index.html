<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- Branding -->
    <title>Christmas Memories Â· N43 Ritual Complete</title>
    <meta name="description" content="Christmas Memories. Annual Ritual v2.0 Complete Edition. Curated by Kelly Hung Â· Nirvana Finance Buddy. Â© NirvanaCity">
    <meta name="author" content="Kelly Hung">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,400&family=Inter:wght@300;400;600&family=Noto+Sans+TC:wght@300;400&display=swap" rel="stylesheet">

    <style>
        /* Reset */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* Base */
        body { 
            overflow: hidden; 
            background-color: #0c0a09; 
            color: #e7e5e4; 
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        
        canvas { touch-action: none; }
        ::-webkit-scrollbar { width: 0; background: transparent; }
        
        /* Fonts */
        .font-ritual { font-family: 'Cormorant Garamond', serif; }
        .font-ui { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        
        /* Colors */
        .text-amber-glow { color: #D4AF37; }
        .text-red-glow { color: #EF4444; }
        .text-cyan-glow { color: #4FD1C5; }
        .text-purple-glow { color: #A78BFA; }
        .text-stone-300 { color: #d6d3d1; }
        .text-stone-400 { color: #a8a29e; }
        .text-stone-500 { color: #78716c; }
        .text-stone-600 { color: #57534e; }
        .text-stone-700 { color: #44403c; }
        .bg-coffee-900 { background-color: #0c0a09; }
        .border-amber-glow { border-color: #D4AF37; }
        .border-red-glow { border-color: #EF4444; }
        .border-cyan-glow { border-color: #4FD1C5; }
        .border-purple-glow { border-color: #A78BFA; }
        .border-stone-600 { border-color: #57534e; }
        .border-stone-700 { border-color: #44403c; }
        .border-stone-800 { border-color: #292524; }
        .bg-amber-glow\/10 { background-color: rgba(212, 175, 55, 0.1); }
        .bg-red-glow\/10 { background-color: rgba(239, 68, 68, 0.1); }
        .bg-cyan-glow\/10 { background-color: rgba(79, 209, 197, 0.1); }
        .bg-purple-glow\/10 { background-color: rgba(167, 139, 250, 0.1); }
        
        /* Glass Panel */
        .glass-panel {
            background: rgba(28, 25, 23, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(212, 175, 55, 0.15);
            border-radius: 4px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
        
        /* Animations */
        @keyframes shimmer { 0% { background-position: -100% 0; } 100% { background-position: 100% 0; } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .loading-bar {
            background: linear-gradient(90deg, #44403c 25%, #78716c 50%, #44403c 75%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite linear;
        }
        
        /* Layout utilities (same as before) */
        .w-full { width: 100%; }
        .h-screen { height: 100vh; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .fixed { position: fixed; }
        .inset-0 { inset: 0; }
        .top-0 { top: 0; }
        .left-0 { left: 0; }
        .bottom-2 { bottom: 0.5rem; }
        .bottom-4 { bottom: 1rem; }
        .bottom-8 { bottom: 2rem; }
        .left-6 { left: 1.5rem; }
        .right-4 { right: 1rem; }
        .right-6 { right: 1.5rem; }
        .z-10 { z-index: 10; }
        .z-50 { z-index: 50; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .gap-2 { gap: 0.5rem; }
        .grid { display: grid; }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .p-2 { padding: 0.5rem; }
        .p-5 { padding: 1.25rem; }
        .p-6 { padding: 1.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .pl-2 { padding-left: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-5 { margin-bottom: 1.25rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-4 { margin-top: 1rem; }
        .text-9px { font-size: 9px; }
        .text-10px { font-size: 10px; }
        .text-xs { font-size: 0.75rem; }
        .text-sm { font-size: 0.875rem; }
        .text-lg { font-size: 1.125rem; }
        .text-xl { font-size: 1.25rem; }
        .text-2xl { font-size: 1.5rem; }
        .text-5xl { font-size: 3rem; }
        .text-7xl { font-size: 4.5rem; }
        .text-center { text-align: center; }
        .italic { font-style: italic; }
        .font-light { font-weight: 300; }
        .font-bold { font-weight: 700; }
        .uppercase { text-transform: uppercase; }
        .tracking-wide { letter-spacing: 0.025em; }
        .tracking-widest { letter-spacing: 0.1em; }
        .leading-tight { line-height: 1.25; }
        .border { border-width: 1px; }
        .border-2 { border-width: 2px; }
        .border-l-2 { border-left-width: 2px; }
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-full { border-radius: 9999px; }
        .overflow-hidden { overflow: hidden; }
        .pointer-events-none { pointer-events: none; }
        .cursor-pointer { cursor: pointer; }
        .object-cover { object-fit: cover; }
        .hidden { display: none; }
        .transform { transform: translateZ(0); }
        .scale-x-\[-1\] { transform: scaleX(-1); }
        .translate-y-0 { transform: translateY(0); }
        .translate-y-20 { transform: translateY(5rem); }
        .transition-all { transition: all 0.3s; }
        .transition-opacity { transition: opacity 0.3s; }
        .duration-500 { transition-duration: 500ms; }
        .duration-1000 { transition-duration: 1000ms; }
        .duration-\[2000ms\] { transition-duration: 2000ms; }
        .opacity-0 { opacity: 0; }
        .opacity-30 { opacity: 0.3; }
        .opacity-100 { opacity: 1; }
        .w-24 { width: 6rem; }
        .h-16 { height: 4rem; }
        .w-32 { width: 8rem; }
        .h-1 { height: 0.25rem; }
        .w-2 { width: 0.5rem; }
        .h-2 { height: 0.5rem; }
        
        input[type="file"] { display: none; }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 0.25rem;
            border-radius: 0.5rem;
            background: #44403c;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #D4AF37;
            cursor: pointer;
        }
        
        .group:hover .group-hover\:opacity-100 { opacity: 1; }
        .hover\:border-stone-500:hover { border-color: #78716c; }
        
        @media (min-width: 768px) {
            .md\:text-7xl { font-size: 4.5rem; }
            .md\:text-2xl { font-size: 1.5rem; }
            .md\:p-8 { padding: 2rem; }
            .md\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675469240/camera_utils.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@react-three/fiber@8.15.12/dist/react-three-fiber.umd.js"></script>
    <script src="https://unpkg.com/@react-three/drei@9.88.0/dist/drei.umd.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { Canvas, useFrame } = window.ReactThreeFiber;
        const { OrbitControls, PerspectiveCamera, Stars, Sparkles } = window.drei;

        // Complete Vertex Shader with 6 shapes
        const VERTEX_SHADER = `
            uniform float uTime;
            uniform float uExpansion;
            uniform int uShape; // 0=tree, 1=giftbox, 2=uranus, 3=heart, 4=firework, 5=advent
            attribute vec3 aRandom;
            attribute vec4 aUV;
            varying vec2 vUv;
            varying float vExpansion;
            varying float vBrightness;
            varying vec4 vAtlasUV;
            varying vec3 vColor;
            
            void main() {
                vAtlasUV = aUV;
                vExpansion = uExpansion;
                vec3 pos = position;
                
                // SHAPE 0: TREE
                if (uShape == 0) {
                    float breathe = sin(uTime * 1.5 + pos.y * 0.5) * 0.08 * (1.0 - uExpansion);
                    vec3 explodeDir = normalize(pos) * 12.0;
                    vec3 spiralPos = pos + normal * breathe;
                    float t = smoothstep(0.0, 1.0, uExpansion);
                    vec3 drift = vec3(sin(uTime * 0.5 + aRandom.x * 10.0), cos(uTime * 0.3 + aRandom.y * 10.0), sin(uTime * 0.4 + aRandom.z * 10.0)) * 0.5 * t;
                    pos = mix(spiralPos, spiralPos + explodeDir * aRandom.x * 2.5 + drift, t);
                    vColor = vec3(0.83, 0.68, 0.21);
                }
                
                // SHAPE 1: GIFT BOX
                else if (uShape == 1) {
                    float boxSize = 3.0;
                    int idx = int(aRandom.z * 125.0);
                    int x = idx % 5;
                    int y = (idx / 5) % 5;
                    int z = idx / 25;
                    pos.x = (float(x) - 2.0) * boxSize / 5.0;
                    pos.y = (float(y) - 2.0) * boxSize / 5.0;
                    pos.z = (float(z) - 2.0) * boxSize / 5.0;
                    vColor = (y == 4) ? vec3(0.9, 0.2, 0.2) : vec3(0.9, 0.7, 0.2);
                    if (uExpansion > 0.0) {
                        vec3 explosionDir = normalize(pos) * 8.0;
                        float rotation = uExpansion * 3.14159;
                        pos += explosionDir * uExpansion;
                        pos.x += sin(rotation + aRandom.x * 6.28) * 2.0 * uExpansion;
                        pos.z += cos(rotation + aRandom.y * 6.28) * 2.0 * uExpansion;
                    }
                }
                
                // SHAPE 2: URANUS
                else if (uShape == 2) {
                    float radius = 3.5;
                    int particleIndex = int(aRandom.z * 203.0);
                    if (particleIndex < 150) {
                        float theta = aRandom.x * 6.28318;
                        float phi = aRandom.y * 3.14159;
                        pos.x = radius * sin(phi) * cos(theta);
                        pos.y = radius * sin(phi) * sin(theta);
                        pos.z = radius * cos(phi);
                        vColor = mix(vec3(0.31, 0.82, 0.77), vec3(0.22, 0.70, 0.67), aRandom.y);
                    } else if (particleIndex < 176) {
                        float angle = aRandom.x * 6.28318;
                        float ringRadius = radius * 1.6;
                        pos.x = ringRadius * cos(angle);
                        pos.z = ringRadius * sin(angle);
                        pos.y = 0.0;
                        float temp = pos.y; pos.y = pos.z; pos.z = temp;
                        vColor = vec3(0.7, 0.96, 0.92);
                    } else {
                        float orbitRadius = radius * (2.0 + aRandom.y);
                        float angle = uTime * 0.3 + aRandom.x * 6.28318;
                        float tilt = aRandom.z * 1.57;
                        pos.x = orbitRadius * cos(angle);
                        pos.y = orbitRadius * sin(angle) * sin(tilt);
                        pos.z = orbitRadius * sin(angle) * cos(tilt);
                        vColor = vec3(0.8, 0.9, 1.0);
                    }
                    float rotationAngle = uTime * 0.1;
                    float cosR = cos(rotationAngle);
                    float sinR = sin(rotationAngle);
                    float y2 = pos.y * cosR - pos.z * sinR;
                    float z2 = pos.y * sinR + pos.z * cosR;
                    pos.y = y2;
                    pos.z = z2;
                    if (uExpansion > 0.0) {
                        vec3 explosionDir = normalize(pos) * 10.0;
                        pos = mix(pos, pos + explosionDir, uExpansion);
                    }
                }
                
                // SHAPE 3: HEART
                else if (uShape == 3) {
                    float t = aRandom.x * 6.28318;
                    float scale = 2.5;
                    float x = 16.0 * pow(sin(t), 3.0);
                    float y = 13.0 * cos(t) - 5.0 * cos(2.0*t) - 2.0 * cos(3.0*t) - cos(4.0*t);
                    pos.x = x * scale / 16.0;
                    pos.y = (y - 8.0) * scale / 16.0;
                    pos.z = (aRandom.y - 0.5) * 0.5;
                    vColor = mix(vec3(0.937, 0.267, 0.267), vec3(0.988, 0.596, 0.596), aRandom.z);
                    if (uExpansion > 0.0) {
                        vec3 explosionDir = normalize(vec3(pos.x, pos.y, 0.0)) * 8.0;
                        pos += explosionDir * uExpansion;
                        pos.z += sin(uTime * 2.0 + aRandom.x * 10.0) * 2.0 * uExpansion;
                    }
                }
                
                // SHAPE 4: FIREWORK
                else if (uShape == 4) {
                    float radius = 0.5;
                    float theta = aRandom.x * 6.28318;
                    float phi = aRandom.y * 3.14159;
                    pos.x = radius * sin(phi) * cos(theta);
                    pos.y = radius * sin(phi) * sin(theta);
                    pos.z = radius * cos(phi);
                    float hue = aRandom.z;
                    if (hue < 0.33) vColor = vec3(0.937, 0.267, 0.267);
                    else if (hue < 0.66) vColor = vec3(0.267, 0.937, 0.267);
                    else vColor = vec3(0.267, 0.267, 0.937);
                    if (uExpansion > 0.0) {
                        vec3 explosionDir = normalize(pos) * 15.0;
                        float speed = 1.0 + aRandom.y * 2.0;
                        pos += explosionDir * uExpansion * speed;
                        pos.y -= uExpansion * uExpansion * 3.0;
                    }
                }
                
                // SHAPE 5: ADVENT CALENDAR
                else if (uShape == 5) {
                    int idx = int(aRandom.z * 24.0);
                    int col = idx % 6;
                    int row = idx / 6;
                    float spacing = 1.5;
                    pos.x = (float(col) - 2.5) * spacing;
                    pos.y = (2.0 - float(row)) * spacing;
                    pos.z = 0.0;
                    vColor = vec3(0.8, 0.8, 0.85);
                    if (uExpansion > 0.0) {
                        float flipProgress = (uExpansion - float(idx) / 24.0) * 24.0;
                        if (flipProgress > 0.0) {
                            pos.z = sin(flipProgress * 3.14159) * 2.0;
                            pos.y += (1.0 - cos(flipProgress * 3.14159)) * 1.0;
                        }
                    }
                }
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                float dist = -mvPosition.z;
                float dotSize = 25.0 * (1.0 + aRandom.z * 0.5);
                float photoSize = 350.0;
                float currentSize = mix(dotSize, photoSize, uExpansion);
                gl_PointSize = currentSize * (1.0 / dist);
                vUv = uv;
                vBrightness = 0.6 + 0.4 * sin(uTime * 2.0 + aRandom.y * 20.0);
            }
        `;

        const FRAGMENT_SHADER = `
            uniform sampler2D uTexture;
            uniform float uHasTexture;
            uniform int uShape;
            uniform float uTime;
            varying float vExpansion;
            varying float vBrightness;
            varying vec4 vAtlasUV;
            varying vec3 vColor;

            void main() {
                vec2 uv = gl_PointCoord;
                float dist = length(uv - 0.5);
                if (dist > 0.5) discard;
                float glow = 1.0 - (dist * 2.0);
                glow = pow(glow, 2.5);
                float sparkle = (uShape == 2) ? sin(uTime * 5.0 + dist * 10.0) * 0.5 + 0.5 : 1.0;
                vec3 color = vColor * (0.8 + vBrightness * 0.4) * sparkle;
                vec4 colorDot = vec4(color * 1.5, glow * 0.8);
                vec4 colorPhoto = vec4(0.0);
                if (uHasTexture > 0.5) {
                    vec2 photoUV = vec2(vAtlasUV.x + uv.x * vAtlasUV.z, vAtlasUV.y + uv.y * vAtlasUV.w);
                    colorPhoto = texture2D(uTexture, photoUV);
                    vec3 warmFilter = vec3(1.0, 0.95, 0.9);
                    colorPhoto.rgb = colorPhoto.rgb * warmFilter;
                    float border = 0.03;
                    if (uv.x < border || uv.x > 1.0 - border || uv.y < border || uv.y > 1.0 - border) {
                        colorPhoto = vec4(0.9, 0.85, 0.8, 0.9);
                    }
                } else {
                    colorPhoto = vec4(color * 2.0, glow);
                }
                float mixFactor = smoothstep(0.15, 0.7, vExpansion);
                if (uHasTexture < 0.5) {
                    gl_FragColor = colorDot;
                } else {
                    vec4 finalColor = mix(colorDot, colorPhoto, mixFactor);
                    finalColor.a = mix(glow, 1.0, mixFactor);
                    gl_FragColor = finalColor;
                }
            }
        `;

        const createTextureAtlas = async (files, onProgress) => {
            const size = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            if (!ctx) return null;
            const processFiles = files.slice(0, 30);
            const cols = Math.ceil(Math.sqrt(processFiles.length));
            const rows = Math.ceil(processFiles.length / cols);
            const itemW = size / cols;
            const itemH = size / rows;
            const uvs = [];
            for (let i = 0; i < processFiles.length; i++) {
                if (onProgress) onProgress((i / processFiles.length) * 100);
                const img = new Image();
                img.src = URL.createObjectURL(processFiles[i]);
                await new Promise((resolve) => { img.onload = resolve; });
                const x = (i % cols) * itemW;
                const y = Math.floor(i / cols) * itemH;
                const scale = Math.max(itemW / img.width, itemH / img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                const offsetX = (itemW - w) / 2;
                const offsetY = (itemH - h) / 2;
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, itemW, itemH);
                ctx.clip();
                ctx.drawImage(img, x + offsetX, y + offsetY, w, h);
                ctx.restore();
                uvs.push({ x: x / size, y: 1.0 - ((y + itemH) / size), w: itemW / size, h: itemH / size });
            }
            if (onProgress) onProgress(100);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.needsUpdate = true;
            return { texture, uvs };
        };

        const PhotoTree = ({ atlasData, expansion, count, shape }) => {
            const shaderRef = useRef();
            const shapeMap = { tree: 0, giftbox: 1, uranus: 2, heart: 3, firework: 4, advent: 5 };
            const shapeIndex = shapeMap[shape] || 0;
            
            const { positions, randoms } = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const rnd = new Float32Array(count * 3);
                const height = 14, radius = 3.5, loops = 7;
                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const angle = t * loops * Math.PI * 2;
                    const y = height * (0.5 - t);
                    const r = radius * t + (Math.random() - 0.5) * 0.5;
                    pos[i * 3] = Math.cos(angle) * r;
                    pos[i * 3 + 1] = y;
                    pos[i * 3 + 2] = Math.sin(angle) * r;
                    rnd[i * 3] = Math.random();
                    rnd[i * 3 + 1] = Math.random();
                    rnd[i * 3 + 2] = Math.random();
                }
                return { positions: pos, randoms: rnd };
            }, [count]);

            const uvs = useMemo(() => {
                const arr = new Float32Array(count * 4);
                if (!atlasData) return arr;
                for(let i=0; i<count; i++) {
                    const imgData = atlasData.uvs[i % atlasData.uvs.length];
                    arr[i*4] = imgData.x;
                    arr[i*4+1] = imgData.y;
                    arr[i*4+2] = imgData.w;
                    arr[i*4+3] = imgData.h;
                }
                return arr;
            }, [atlasData, count]);

            useFrame((state) => {
                if (shaderRef.current) {
                    shaderRef.current.uniforms.uTime.value = state.clock.elapsedTime;
                    shaderRef.current.uniforms.uShape.value = shapeIndex;
                    shaderRef.current.uniforms.uExpansion.value = THREE.MathUtils.lerp(
                        shaderRef.current.uniforms.uExpansion.value, expansion, 0.08
                    );
                    if (atlasData) {
                        shaderRef.current.uniforms.uTexture.value = atlasData.texture;
                        shaderRef.current.uniforms.uHasTexture.value = 1.0;
                    } else {
                        shaderRef.current.uniforms.uHasTexture.value = 0.0;
                    }
                }
            });

            return (
                <points>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
                        <bufferAttribute attach="attributes-aRandom" count={count} array={randoms} itemSize={3} />
                        <bufferAttribute attach="attributes-aUV" count={count} array={uvs} itemSize={4} />
                    </bufferGeometry>
                    <shaderMaterial
                        ref={shaderRef}
                        uniforms={{
                            uTime: { value: 0 },
                            uExpansion: { value: 0 },
                            uTexture: { value: null },
                            uHasTexture: { value: 0.0 },
                            uShape: { value: shapeIndex }
                        }}
                        vertexShader={VERTEX_SHADER}
                        fragmentShader={FRAGMENT_SHADER}
                        transparent={true}
                        depthWrite={false}
                        blending={THREE.AdditiveBlending}
                    />
                </points>
            );
        };

        const HandTracker = ({ onHandUpdate }) => {
            const videoRef = useRef(null);
            const smoothedOpenness = useRef(0);
            useEffect(() => {
                let camera = null, hands = null;
                const onResults = (results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        const wrist = landmarks[0], middleTip = landmarks[12], indexMCP = landmarks[5];
                        const distTip = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
                        const distRef = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y);
                        const ratio = distTip / distRef;
                        let rawOpenness = (ratio - 0.8) / (2.0 - 0.8);
                        rawOpenness = Math.max(0, Math.min(1, rawOpenness));
                        const alpha = 0.15;
                        smoothedOpenness.current = smoothedOpenness.current * (1 - alpha) + rawOpenness * alpha;
                        let output = smoothedOpenness.current;
                        if (output < 0.05) output = 0;
                        if (output > 0.95) output = 1;
                        onHandUpdate(output);
                    }
                };
                const initMediaPipe = async () => {
                    if (!window.Hands) { setTimeout(initMediaPipe, 100); return; }
                    hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    hands.onResults(onResults);
                    if (videoRef.current) {
                        camera = new window.Camera(videoRef.current, {
                            onFrame: async () => { await hands.send({image: videoRef.current}); },
                            width: 640, height: 480
                        });
                        camera.start();
                    }
                };
                initMediaPipe();
                return () => { 
                    if (camera) try { camera.stop(); } catch(e) {}
                    if (hands) try { hands.close(); } catch(e) {}
                };
            }, []);
            return <video ref={videoRef} className="fixed bottom-4 right-4 w-24 h-16 object-cover rounded border opacity-30 pointer-events-none transform scale-x-[-1] z-50" style={{borderColor: 'rgba(212, 175, 55, 0.2)'}} playsInline muted />;
        };

        const App = () => {
            const [images, setImages] = useState([]);
            const [expansion, setExpansion] = useState(0);
            const [useCamera, setUseCamera] = useState(false);
            const [manualExpansion, setManualExpansion] = useState(0);
            const [isWelcome, setIsWelcome] = useState(true);
            const [buildProgress, setBuildProgress] = useState(0);
            const [isBuilding, setIsBuilding] = useState(false);
            const [atlasData, setAtlasData] = useState(null);
            const [shape, setShape] = useState('tree');

            useEffect(() => {
                const timer = setTimeout(() => setIsWelcome(false), 5000);
                return () => clearTimeout(timer);
            }, []);

            const handleUpload = async (e) => {
                if (e.target.files && e.target.files.length > 0) {
                    const filesArr = Array.from(e.target.files).slice(0, 30);
                    setImages(filesArr);
                    setIsBuilding(true);
                    setBuildProgress(0);
                    const data = await createTextureAtlas(filesArr, (progress) => {
                        setBuildProgress(prev => Math.max(prev, progress));
                    });
                    if (data) setAtlasData(data);
                    setIsBuilding(false);
                }
            };

            const currentExpansion = useCamera ? expansion : manualExpansion;

            const shapes = [
                { id: 'tree', icon: 'ðŸŽ„', name: 'Tree', theme: 'Christmas', color: 'amber' },
                { id: 'giftbox', icon: 'ðŸŽ', name: 'Gift', theme: 'Surprise', color: 'amber' },
                { id: 'heart', icon: 'â¤ï¸', name: 'Heart', theme: 'Love', color: 'red' },
                { id: 'firework', icon: 'ðŸŽ†', name: 'Firework', theme: 'Celebration', color: 'purple' },
                { id: 'advent', icon: 'ðŸ“…', name: 'Advent', theme: 'Countdown', color: 'amber' },
                { id: 'uranus', icon: 'ðŸŒ€', name: 'Uranus', theme: 'Innovation', color: 'cyan' }
            ];

            const getLightColor = () => {
                if (shape === 'uranus') return '#4FD1C5';
                if (shape === 'heart') return '#EF4444';
                if (shape === 'firework') return '#A78BFA';
                return '#D4AF37';
            };

            return (
                <div className="w-full h-screen relative bg-coffee-900 overflow-hidden">
                    <div className={`absolute inset-0 z-50 flex flex-col items-center justify-center bg-coffee-900 transition-opacity duration-[2000ms] ${isWelcome ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                        <h1 className="font-ritual text-5xl md:text-7xl text-amber-glow tracking-widest mb-4 animate-pulse text-center">
                            N43 RITUAL<br/>
                            <span className="text-xl md:text-2xl font-ui font-light mt-2 block" style={{letterSpacing: '0.2em', opacity: 0.6, color: '#8B5E3C'}}>Complete Edition</span>
                        </h1>
                        <p className="font-ritual text-stone-400 text-lg italic mt-4 text-center" style={{maxWidth: '28rem'}}>
                            Six shapes. Infinite memories.<br/>
                            Every year deserves a ritual.
                        </p>
                        <p className="font-ui text-xs text-stone-500 mt-4 tracking-wide">Curated by Kelly Hung</p>
                    </div>

                    <Canvas>
                        <PerspectiveCamera makeDefault position={[0, 0, 25]} fov={60} />
                        <OrbitControls enablePan={false} autoRotate={currentExpansion < 0.1} autoRotateSpeed={0.8} minDistance={10} maxDistance={40} />
                        <color attach="background" args={['#0c0a09']} />
                        <Stars radius={100} depth={50} count={3000} factor={4} saturation={0} fade speed={0.5} />
                        <ambientLight intensity={0.4} color="#8B5E3C" />
                        <pointLight position={[10, 10, 10]} intensity={0.8} color={getLightColor()} />
                        <PhotoTree atlasData={atlasData} expansion={currentExpansion} count={180} shape={shape} />
                        <Sparkles count={80} scale={15} size={2} speed={0.2} opacity={0.3} color={getLightColor()} />
                    </Canvas>

                    <div className={`absolute top-0 left-0 w-full p-6 md:p-8 transition-opacity duration-1000 flex flex-col items-start pointer-events-none ${isWelcome ? 'opacity-0' : 'opacity-100'}`}>
                        <h2 className="font-ritual text-2xl text-amber-glow leading-tight">
                            Christmas Memories
                        </h2>
                        <div className="font-ui text-10px text-stone-500 mt-1 tracking-widest uppercase border-l-2 border-stone-800 pl-2">
                            <p>Annual Ritual v2.0</p>
                        </div>
                    </div>

                    <div className={`absolute bottom-8 left-6 right-6 glass-panel p-5 transition-transform duration-1000 ${isWelcome ? 'translate-y-20 opacity-0' : 'translate-y-0 opacity-100'}`} style={{maxWidth: '22rem'}}>
                        {isBuilding && (
                            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center rounded" style={{backgroundColor: 'rgba(12, 10, 9, 0.95)'}}>
                                <span className="font-ritual text-amber-glow text-xl mb-1">Weaving...</span>
                                <div className="w-32 h-1 rounded overflow-hidden" style={{backgroundColor: '#44403c'}}>
                                    <div className="h-full bg-amber-glow loading-bar" style={{width: `${buildProgress}%`}}></div>
                                </div>
                            </div>
                        )}

                        <div className="mb-4">
                            <label className="block font-ui text-10px font-bold uppercase tracking-widest text-stone-400 mb-2">
                                Particle Shape
                            </label>
                            <div className="grid grid-cols-3 md:grid-cols-3 gap-2">
                                {shapes.map(s => (
                                    <button
                                        key={s.id}
                                        onClick={() => setShape(s.id)}
                                        className={`border rounded-lg p-2 transition-all ${
                                            shape === s.id
                                                ? `border-${s.color}-glow bg-${s.color}-glow\/10`
                                                : 'border-stone-700 hover:border-stone-500'
                                        }`}
                                        style={shape === s.id ? {
                                            borderColor: s.color === 'amber' ? '#D4AF37' : s.color === 'red' ? '#EF4444' : s.color === 'cyan' ? '#4FD1C5' : '#A78BFA',
                                            backgroundColor: s.color === 'amber' ? 'rgba(212,175,55,0.1)' : s.color === 'red' ? 'rgba(239,68,68,0.1)' : s.color === 'cyan' ? 'rgba(79,209,197,0.1)' : 'rgba(167,139,250,0.1)'
                                        } : {}}
                                    >
                                        <div className="text-2xl mb-1">{s.icon}</div>
                                        <div className="text-xs font-bold">{s.name}</div>
                                        <div className="text-9px text-stone-600">{s.theme}</div>
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div className="mb-4">
                            <label className="cursor-pointer group flex items-center justify-between border border-stone-600 rounded px-4 py-3 transition-all" style={{backgroundColor: 'rgba(28, 25, 23, 0.5)'}}>
                                <span className="text-stone-300 text-sm">{images.length > 0 ? `${images.length} Photos` : "Upload Photos"}</span>
                                <input type="file" multiple accept="image/*" onChange={handleUpload} />
                                <div className="w-2 h-2 rounded-full bg-amber-glow opacity-50 group-hover:opacity-100"></div>
                            </label>
                        </div>

                        <div>
                            <div className="flex gap-2 mb-2">
                                <button onClick={() => setUseCamera(false)} className={`flex-1 py-2 border rounded transition-all text-xs ${!useCamera ? 'border-amber-glow' : 'border-stone-700'}`} style={!useCamera ? {borderColor: '#D4AF37', color: '#D4AF37', backgroundColor: 'rgba(212,175,55,0.1)'} : {}}>Slider</button>
                                <button onClick={() => setUseCamera(true)} className={`flex-1 py-2 border rounded transition-all text-xs ${useCamera ? 'border-amber-glow' : 'border-stone-700'}`} style={useCamera ? {borderColor: '#D4AF37', color: '#D4AF37', backgroundColor: 'rgba(212,175,55,0.1)'} : {}}>Camera</button>
                            </div>
                            <div className={`${useCamera ? 'opacity-30 pointer-events-none' : ''}`}>
                                <input type="range" min="0" max="1" step="0.001" value={manualExpansion} onChange={(e) => setManualExpansion(parseFloat(e.target.value))} />
                            </div>
                        </div>
                    </div>

                    <div className={`absolute bottom-2 w-full text-center pointer-events-none transition-opacity duration-1000 ${isWelcome ? 'opacity-0' : 'opacity-100'}`}>
                        <p className="font-ui text-9px text-stone-700 tracking-widest uppercase">Â© NirvanaCity</p>
                    </div>

                    {useCamera && <HandTracker onHandUpdate={setExpansion} />}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
